requirements:

update the data.jsx file that will directly interact with firebase
heres the required functions:

Collections Structure:
1. qr_client/
   - clientId (auto-generated document ID)
   - name: string
   - email: string  
   - phone: string
   - password: string (hashed in production using Firebase Auth)
   - role: 'client' | 'admin'
   - qrCode: string
   - url: string
   - createdAt: timestamp
   - lastUpdated: timestamp

2. qr_registrations/
   - registrationId (auto-generated document ID)
   - clientId: string (reference to client)
   - qrCode: string
   - name: string
   - email: string
   - phone: string
   - timestamp: timestamp
   - createdAt: timestamp

3. qr_admin/ (single document for admin settings)
   - settings (map)
     - initialized: boolean
     - lastUpdated: timestamp

role: ADMIN
use cases with authentication:
	=> can create a client, client has unique qr code attached to their id
	=> clients created will have a suffix of xxxxxx@client.com  and a mock password generated by the admin 
	=> can update client data (except password)
	=> can view client data (how many registrations have each client made)
	=> can delete client from database
	
	==> operations will use firease authentication to createEmail and createPassword
	
	collection name: qr_admin
	collection relationships: qr_client
	
	
	
Task:
create a script thatll directly interact with firebase
create a ruleset that provides all relevant permissions for ADMIN

CREATE A SIMPLE ADMIN CREATION AND LOGIN FOR ADMIN FIRST

THEN CLIENT LOGIN NEXT AND REGISTRATION LOGIC LATER...
SIMPLE AND STUPID BUT FUNCTIONAL SECURE.


CONSTRAINTS: THE data.jsx file is interlinked with login, regitration, admin and client dashboards, and app.js DO NOT CHANGE THE NAMING CONVENTIONS OF ANY FUNCTION
	
current ruleset: NOT WORKING AS INTENDED.....

// Updated security rules for Firestore with comprehensive admin permissions
	rules_version = '2';
	service cloud.firestore {
	  match /databases/{database}/documents {
		// Check if user is an admin
		
		
		// Check if user is a QR admin (enhanced for better admin control)
		function isQRAdmin() {
		  return request.auth != null && 
		    exists(/databases/$(database)/documents/qr_client/$(request.auth.uid)) &&
		    get(/databases/$(database)/documents/qr_client/$(request.auth.uid)).data.role == 'admin';
		}
		
		
		
		// Check if user owns the client document
		function isClientOwner(clientId) {
		  return request.auth != null && request.auth.uid == clientId;
		}
		
		// Check if user is admin or owns the resource
		function isAdminOrOwner(ownerId) {
		  return isQRAdmin() || (request.auth != null && request.auth.uid == ownerId);
		}
		
		// Check if system is initialized
		function isSystemInitialized() {
		  return exists(/databases/$(database)/documents/qr_admin/settings) &&
		    get(/databases/$(database)/documents/qr_admin/settings).data.settings.initialized == true;
		}
		
		// Default: deny all
		match /{document=**} {
		  allow read, write: if false;
		}
	

		// ==================== QR SYSTEM RULES ====================
		
		// QR Admin settings - Enhanced for system initialization and admin control
		match /qr_admin/{document} {
		  // Allow reading by QR admins and during initialization check
		  allow read: if isQRAdmin() || !isSystemInitialized();
		  
		  // Allow creation if no settings exist yet (for initialization) or by QR admin
		  allow create: if !isSystemInitialized() || isQRAdmin();
		  
		  // Allow updates and deletes by QR admins only
		  allow update, delete: if isQRAdmin();
		}
		
		// QR Clients collection - COMPREHENSIVE ADMIN CONTROL
		match /qr_client/{clientId} {
		  // Reading permissions:
		  // - QR Admins can read all client documents
		  // - Clients can read their own document
		  // - Allow unauthenticated read during system initialization
		  allow read: if isQRAdmin() || 
		                 isClientOwner(clientId) ||
		                 !isSystemInitialized();
		  
		  // Creation permissions:
		  // - QR Admins can create any client (for admin-created clients)
		  // - Allow creation during system initialization
		  // - Users can create their own client document (self-registration)
		  allow create: if isQRAdmin() || 
		                   !isSystemInitialized() ||
		                   (request.auth != null && request.auth.uid == clientId);
		  
		  // Update permissions:
		  // - QR Admins can update any client
		  // - Clients can update their own document
		  allow update: if isQRAdmin() || 
		                   isClientOwner(clientId);
		  
		  // Delete permissions:
		  // - Only QR Admins can delete clients
		  allow delete: if isQRAdmin();
		}
		
		// QR Registrations collection - ENHANCED for admin oversight
		match /qr_registrations/{registrationId} {
		  // Reading permissions:
		  // - QR Admins can read all registrations
		  // - Authenticated users can read all registrations (for client dashboards)
		  // - Public read access for QR code scanning functionality
		  allow read: if isQRAdmin() || 
		                 request.auth != null ||
		                 true; // Public read for QR scanning
		  
		  // Creation permissions:
		  // - Anyone can create registrations (public QR code scanning)
		  // - This enables users scanning QR codes to register without authentication
		  allow create: if true;
		  
		  // Update permissions:
		  // - QR Admins can update any registration
		  // - Client owners can update registrations associated with their QR codes
		  allow update: if isQRAdmin() || 
		                   (request.auth != null && 
		                    exists(/databases/$(database)/documents/qr_client/$(request.auth.uid)) &&
		                    get(/databases/$(database)/documents/qr_client/$(request.auth.uid)).data.qrCode == resource.data.qrCode);
		  
		  // Delete permissions:
		  // - QR Admins can delete any registration
		  // - Client owners can delete registrations associated with their QR codes
		  allow delete: if isQRAdmin() || 
		                   (request.auth != null && 
		                    exists(/databases/$(database)/documents/qr_client/$(request.auth.uid)) &&
		                    get(/databases/$(database)/documents/qr_client/$(request.auth.uid)).data.qrCode == resource.data.qrCode);
		}

		// QR System Analytics collection (optional - for future use)
		match /qr_analytics/{analyticsId} {
		  // Only QR Admins can access analytics
		  allow read, write, create, update, delete: if isQRAdmin();
		}

		// QR System Logs collection (optional - for audit trails)
		match /qr_logs/{logId} {
		  // QR Admins can read all logs
		  allow read: if isQRAdmin();
		  
		  // System can create logs, QR Admins can create logs
		  allow create: if isQRAdmin() || true; // Allow system to create logs
		  
		  // Only QR Admins can update/delete logs
		  allow update, delete: if isQRAdmin();
		}

		// QR Client Backups collection (optional - for data backup)
		match /qr_client_backups/{backupId} {
		  // Only QR Admins can access backups
		  allow read, write, create, update, delete: if isQRAdmin();
		}
	  }
	}

=====================================/ App.js /===================================================================

App.js:
import React, { useState, useEffect } from 'react';
import { HashRouter as Router, Routes, Route, Link, useParams, useNavigate } from 'react-router-dom';
import { QRCodeSVG } from 'qrcode.react';

import HomePage from './components/Homepage.jsx';
import AboutPage from './components/Pages/About.jsx';
import ServicesPage from './components/Pages/Services.jsx';
import ContactPage from './components/Pages/Contact.jsx';
import LoginPage from './components/AnA/login.jsx';
import RegisterPage from './components/AnA/Registration.jsx';
import AdminDashboard from './components/Admin/dashboard.jsx';
import Navbar from './components/Pages/Navbar.jsx';
import Footer from './components/Pages/Footer.jsx';
import authUtils from './utils/auth_util.jsx';
import { firebaseUtils, clientOperationsUtils } from './components/data.jsx';
import ClientDashboard from './components/Client/dashboard.jsx';
import ColorFest from './components/Events/colorfest.jsx';

// Main App Component
const App = () => {
  const [isAdmin, setIsAdmin] = useState(false);
  const [isClient, setIsClient] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Initialize Firebase and user state on first load
    initializeApp();
  }, []);
  

  const initializeApp = async () => {
    try {
      // Initialize admin account if not exists
      await firebaseUtils.initializeAdmin();
      
      // Initialize sample client data for demo purposes
      await clientOperationsUtils.initializeSampleClient();
      
      // Check if user is already logged in
      await initializeUserState();
    } catch (error) {
      console.error('Error initializing app:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const initializeUserState = async () => {
    try {
      // Check for stored session data using Firebase auth utils
      const storedUser = authUtils.getCurrentUser();
      const storedRole = authUtils.getCurrentRole();
      
      if (storedUser && storedRole) {
        setCurrentUser(storedUser);
        
        if (storedRole === 'admin') {
          setIsAdmin(true);
          setIsClient(false);
        } else if (storedRole === 'client') {
          setIsClient(true);
          setIsAdmin(false);
        }
      }
    } catch (error) {
      console.error('Error initializing user state:', error);
      // Clear corrupted data
      authUtils.clearAuth();
    }
  };

  const handleLogin = async (role, userData = null) => {
    try {
      // If userData is provided, use it directly
      if (userData) {
        // Store login state using Firebase auth utils
        authUtils.setCurrentUser(userData);
        setCurrentUser(userData);

        if (role === 'admin') {
          setIsAdmin(true);
          setIsClient(false);
        } else if (role === 'client') {
          setIsClient(true);
          setIsAdmin(false);
        }
        return;
      }

      // If no userData provided, this is a logout scenario
      handleLogout();
    } catch (error) {
      console.error('Error during login:', error);
    }
  };

  const handleLogout = () => {
    // Clear all login state
    setIsAdmin(false);
    setIsClient(false);
    setCurrentUser(null);
    
    // Clear Firebase auth session
    authUtils.signOut();
  };

  // Show loading spinner while initializing
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Initializing Firebase...</p>
        </div>
      </div>
    );
  }

  return (
    <Router>
      <div className="min-h-screen bg-gray-50">
        <Navbar
          isAdmin={isAdmin}
          isClient={isClient}
          currentUser={currentUser}
          onSetIsAdmin={setIsAdmin}
          onSetIsClient={setIsClient}
          onLogout={handleLogout}
        />
        <main>
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/qr-prototype" element={<HomePage />} />
            <Route path="/qr-prototype/about" element={<AboutPage />} />
            <Route path="/qr-prototype/services" element={<ServicesPage />} />
            <Route path="/qr-prototype/contact" element={<ContactPage />} />

            <Route 
              path="/qr-prototype/login" 
              element={
                <LoginPage 
                  onLogin={handleLogin} 
                  isLoggedIn={isAdmin || isClient}
                  
                  authUtils={authUtils}
                  firebaseUtils={firebaseUtils}
                  clientOperationsUtils={clientOperationsUtils}
                />
              } 
            />
            <Route path="/register/:qrCode" element={<ColorFest />} />

            {isAdmin && (
              <Route 
                path="/qr-prototype/admin" 
                element={<AdminDashboard currentUser={currentUser} />} 
              />
            )}

            {isClient && (
              <Route 
                path="/qr-prototype/client" 
                element={<ClientDashboard currentUser={currentUser} />} 
              />
            )}
          </Routes>
        </main>
        <Footer />
      </div>
    </Router>
  );
};

export default App;

============================//AUTHENTICATION HELPER FUNCTIONS /===================================
auth_util.js:
import { 
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  deleteUser
} from 'firebase/auth';
import { 
  doc, 
  setDoc, 
  serverTimestamp 
} from 'firebase/firestore';
import { auth, db } from '../config/firebase';
import { firebaseUtils } from '../components/data';




const authUtils = {
  // Sign in user with Firebase Auth
  signIn: async (email, password) => {
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;
      
      // Get user role from Firestore after authentication
      const userData = await firebaseUtils.getClientById(user.uid);
      
      if (userData) {
        authUtils.setCurrentUser({
          id: user.uid,
          email: user.email,
          ...userData
        });
        return userData;
      }
      
      throw new Error('User data not found in database');
    } catch (error) {
      console.error('Error signing in:', error);
      throw error;
    }
  },

  // Create new user account
createUser: async (email, password, userData) => {
let userCredential; // Declare here to use in catch block

  try {
    // First create the Firebase Auth user
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    const user = userCredential.user;
    
    // Prepare client data
    const clientData = {
      ...userData,
      email: user.email,
      firebaseUid: user.uid, // Store the Firebase UID
      createdAt: serverTimestamp(),
      lastUpdated: serverTimestamp(),
      passwordInitialized: true
    };
    
    // Create the document with the same ID as the Auth UID
    await setDoc(doc(db, 'qr_clients', user.uid), clientData);
    
    return {
      id: user.uid,
      email: user.email,
      ...clientData
    };
  } catch (error) {
    console.error('Error creating user:', error);
    
    // If Firestore write failed, delete the Auth user to keep consistency
    if (error.code === 'permission-denied') {
      try {
        await deleteUser(userCredential.user);
      } catch (deleteError) {
        console.error('Error cleaning up failed user creation:', deleteError);
      }
    }
    
    throw error;
  }
},

  // Sign out
  signOut: async () => {
    try {
      await signOut(auth);
      authUtils.clearAuth();
    } catch (error) {
      console.error('Error signing out:', error);
      throw error;
    }
  },

  // Listen for authentication state changes
  onAuthStateChange: (callback) => {
    return onAuthStateChanged(auth, async (user) => {
      if (user) {
        // User is signed in, get their data from Firestore
        const userData = await firebaseUtils.getClientById(user.uid);
        if (userData) {
          const fullUserData = {
            id: user.uid,
            email: user.email,
            ...userData
          };
          authUtils.setCurrentUser(fullUserData);
          callback(fullUserData);
        } else {
          callback(null);
        }
      } else {
        // User is signed out
        authUtils.clearAuth();
        callback(null);
      }
    });
  },

  // Rest of your existing authUtils methods remain the same
  getCurrentUser: () => {
    try {
      const storedUser = sessionStorage.getItem('currentUser');
      return storedUser ? JSON.parse(storedUser) : null;
    } catch (error) {
      console.error('Error getting current user:', error);
      return null;
    }
  },

  setCurrentUser: (userData) => {
    try {
      sessionStorage.setItem('currentUser', JSON.stringify(userData));
      sessionStorage.setItem('userRole', userData.role);
    } catch (error) {
      console.error('Error setting current user:', error);
    }
  },

  getCurrentRole: () => {
    return sessionStorage.getItem('userRole') || null;
  },

  clearAuth: () => {
    sessionStorage.removeItem('currentUser');
    sessionStorage.removeItem('userRole');
  },

  isAuthenticated: () => {
    return authUtils.getCurrentUser() !== null && authUtils.getCurrentRole() !== null;
  },

  isAdmin: () => {
    return authUtils.getCurrentRole() === 'admin';
  },

  isClient: () => {
    return authUtils.getCurrentRole() === 'client';
  }
};

export default authUtils;



